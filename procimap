#! /usr/bin/perl
#
# procimap - era Thu Dec 16 09:45:54 2005
# Process IMAP folder using Procmail
#
# Based on http://imapassassin.sourceforge.net/ -- forked && hacked extensively
#
# CVS version information in $CVSid below

######## TODO: implement IMAP copy and delete (== refactor move operation)
######## TODO: --dump-config
######## TODO: more debugging hooks
######## TODO: make GroupAccessOK properly configurable

use strict;
use warnings;

use POSIX ":sys_wait_h";
use Getopt::Long;

umask 077;

our $VERSION = 0.01;			######## TODO: update for new version
our $CVSid = '$Id: procimap,v 1.26 2006-01-02 18:06:03 era Exp $';
our $me = $0;
$me =~ s,.*/,,;

my %Conf = ();

# Whether group read/write access to configuration file should be tolerated
######## FIXME: make this an installation-time preference, or something
my $GroupAccessOK = 0;			######## FIXME: currently hardcoded

######## FIXME: temporary
$GroupAccessOK = 1;			######## FIXME: DEBUG

######## FIXME: debugging location; update for production
$Conf{default_wrapper} = "procimap.rc"; ######## FIXME: DEBUG


# Parse options

{
  my $pod = <<'=cut';

=head1 NAME

procimap - sort IMAP mailbox using procmail

=head1 SYNOPSIS

B<procimap> I<options ...>

=head1 DESCRIPTION

B<procimap> provides a facility for applying Procmail recipes
to a remote IMAP mailbox.

Due to the nature of IMAP, some concepts of Procmail
work quite differently in this setting.
These issues are described in more detail below in L<|Procmail Recipes>.


=head2 Options

B<procimap> accepts the following options.
Each is listed with its short form (when available) first,
followed by the equivalent long option,
followed by arguments, if any.

Those options which are marked as "advanced" are primarily
useful for expert use and debugging of B<procimap>'s internals.
Thus, they are not included in the regular B<--help> output,
and should probably be ignored by casual readers of this documentation.

=over 5

=item B<-r>|B<--procmailrc> I<file>

=for Getopt::Long
r procmailrc =s File of procmail recipes to run

By default, B<procimap> looks for F<procimaprc> in the current directory.
Use this option to invoke a different Procmail recipe file.


=item B<-s>|B<--server> I<servername>

=for Getopt::Long
s server =s Specify which IMAP server to connect to

Connect to the IMAP server I<servername>.


=item B<-u>|B<--user> I<username>

=for Getopt::Long
u user =s User account name on IMAP server

Log on to the specified IMAP server as I<username>.


=item B<-p>|B<--password> I<password>

=for Getopt::Long
p password =s Password for IMAP server (careful!)

Use I<password> for logging in on the IMAP server.

B<NOTE:>
You should take extreme caution with this option.
It is only really meant for debugging.
On a multi-user system, anybody can see the
values of the options you pass to your programs
in a simple L<ps(1)> listing.


=item B<-i>|B<--inbox>

=for Getopt::Long
i  inbox =s  Name of inbox folder on server

B<procimap> will filter messages only in the inbox folder on the server.

The default name of the inbox folder is F<INBOX>.


=item B<-x>|B<--expunge>

=for Getopt::Long
x  expunge !  Expunge deleted messages when disconnecting

By default, B<procimap> leaves deleted messages on the server;
they are only marked as deleted.
But if you enable this option, deleted messages will be expunged
at the end of the session.

Use this option with caution;
expunged messages cannot be recovered.


=item B<-d>|B<--delay> I<n>

=for Getopt::Long
d  delay  =i  Delay this many seconds between reconnects

Specify, in seconds, how long to delay before reconnecting to the server.

The default delay is 60 seconds.


=item B<--maxdelay> I<n>

=for Getopt::Long
- maxdelay =i  Maximum delay when server is unavailable

Normally, the delay between reconnects is simply
whatever is specified in the B<delay> parameter.
However, if the server is unavailable when a reconnect is attempted,
the program will delay again, progressively making
each delay longer until it reaches this value.

The default maximum delay is 600 seconds (10 minutes).


=item B<--single-run>

=for Getopt::Long
-  single-run !  Only run once; don't reconnect

Disconnect and quit after processing all new messages
currently on the server.

Normally, B<procimap> runs forever,
reconnecting to the server at intervals specified
by the I<delay> parameter above.


=item B<--statedir> I<directory>

=for Getopt::Long
*  statedir =s  Directory to use for state files

B<procimap> maintains state information between runs
in the specified directory.

The default state directory is F<~/.procimap>


=item B<--pidfile> I<file>

=for Getopt::Long
* pidfile =s    File to use for storing PID

B<procimap> needs to keep track of its own process ID (PID)
to be useful as a background program.

By default, the process ID is saved in F<procimap.pid>.

A relative file name is interpreted relative to the I<statedir>.


=item B<--midfile> I<file>

=for Getopt::Long
* midfile =s    File to use for storing latest MID

B<procimap> needs to keep track of which messages it has seen.

By default, the index number of the newest message B<procimap>
has already processed is saved in F<procimap.mid>.

A relative file name is interpreted relative to the I<statedir>.


=item B<-l>|B<--logfile> I<file>

=for Getopt::Long
l logfile =s  Redirect log output to file

By default, B<procimap> prints logging information to standard error.
These log messages can be redirected to a file with this directive.


=item B<-c>|B<--config> I<file>

=for Getopt::Long
c config  =s  Use an alternative configuration file

Use I<file> as the configuration file
instead of F<~/.procimap/procimap.conf>.


=item B<--message> I<file>

=for Getopt::Long
* message =s Use a canned message; do not connect to IMAP server

For testing your B<procimaprc>, it is useful to
be able to supply a message from a file
instead of actually connecting to an IMAP server
to download real live messages.

Implies B<--single-run>.


=item B<--wrapper> I<file>

=for Getopt::Long
* wrapper =s Use an alternative procmailrc wrapper file

When B<procimap> runs the user's F<procimaprc> file,
it invokes a system F<procimap.rc> wrapper file
which sets up Procmail's internal environment
before invoking the user's own recipe file.
Normally, this is a system file installed
in a library directory,
but for debugging (or fooling around!),
it can occasionally be useful to roll your own.

B<NOTE:> You can mess up your local mail
rather thoroughly if you use this carelessly.


=item B<-V>|B<--verbose>

=for Getopt::Long
V verbose !  Enable verbose diagnostics

Enable verbose diagnostics, or, with B<--help>, verbose help.


=item B<-h>|B<--help>

=for Getopt::Long
h help    !  Print this short help message and exit

Print a short help message and exit.

The regular help message lists only the common options;
use B<--verbose> to get a full option listing
which includes the "advanced" options.


=item B<-v>|B<--version>

=for Getopt::Long
v version !  Print version number and exit

Print version number and exit


=back


=head2 Configuration File Directives

In addition to the options listed above,
B<procimap> can read options from a configuration file.
All of the options listed above can be specified
in the configuration file as well
(except for the ones which only make sense interactively,
i.e. B<version>, B<help>, and, for unrelated reasons, B<config>).
Options specified on the command line
take precedence over the directives in the configuration file.
The syntax is simple; one directive per line,
keyword followed by value, separated by whitespace.
Leading and trailing whitespace is trimmed.


=head2 Procmail Recipes

B<procimap> invokes Procmail on each message,
by default running the Procmail recipes
in the file F<procimaprc>.
This file needs to follow some
conventions in order to communicate properly
with B<procimap>.

First and foremost,
I<no final delivery action should take place>
as this would cause Procmail to stop processing the message,
instead of communicating the filtering result
back to B<procimap>.
If you wish to deliver the message,
use the cloning flag B<:c>
to signal to Procmail to continue processing
nevertheless.

Your recipe should communicate a
filtering result back to B<procimap>
in the F<RESULT> variable.
It should contain one of the following values.

=over 6

=item B<keep>

Keep the message, i.e. simply leave it in the inbox.

=item B<move> I<foldername>

Move the message to the specified folder.
The folder needs to exist on the server.

You will probably need to find out
what the server's folder separator is
and what the folder hierarchy looks like.

The message is deleted from the inbox
once it is successfully stored in the
destination folder.
(IMAP does not have a native move operation,
so this is implemented as copy + delete.)

=cut
######## TODO: implement these
my $XXXXXXXignorepod = <<'=cut';

#item B<copy> I<foldername>

#item B<delete>

=cut

=back

As a fallback mechanism,
if F<RESULT> is unset when Procmail finishes,
it is treated as if it were B<keep>.

=cut

  my $VerboseHelp =
      "$me - sort IMAP mailbox using procmail - version $VERSION\n";

  ######## FIXME: use Pod::Usage instead once it works more like this
  my (@options);
  local $^A = "";
  while ($pod =~ m/^=for Getopt::Long\s*(?:\n\s*)*\n(.*)\n\s*\n/mg) {
    my $option = $1;
    if ($option =~ /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(.*?)\s*$/) {
      my ($short, $long, $type, $desc) = ($1, $2, $3, $4);
      my $shorthelp = " ";
      $shorthelp = "*" if ($short eq "*");
      $short = "" if ($short =~ /^[-*]$/);
      formline <<'________HERE',
@ @<<--@<<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       ~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       ~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       ~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       ~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
       ~          ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
________HERE
	 $shorthelp, ($short ? "-$short|" : "   "), $long, $desc,
	     $desc, $desc, $desc, $desc, $desc;
      push @options, "$long|$short$type";
    }
    else {
      die "$me: Internal error: $1\n";
    }
  }
  die "$0: Internal error: no options defined\n" unless @options;

  $VerboseHelp .= $^A;

  # Construct abridged help message from verbose one
  my $Help = $VerboseHelp;
  $Help =~ s%^\*.*\n%%mg;
  $Help .= "This is an abridged listing, which lacks some advanced options.\n";
  $Help .= "Use --verbose --help to get a listing of all options.\n";

  $VerboseHelp .= "An asterisk * in the margin marks advanced options.\n";

  GetOptions (\%Conf, @options) || exit 2;

  if ($Conf{help}) {
    print $Conf{verbose} ? $VerboseHelp : $Help;
    exit 1;
  }

  if ($Conf{version}) {
    print "$me $VERSION ($CVSid)\n";
    exit 0;
  }
}


# Read in configuration file

$Conf{statedir_default} = "$ENV{HOME}/.procimap";
$Conf{config} ||= "$Conf{statedir_default}/procimap.conf";

{
  ######## FIXME: this is awfully U*x-centric; "use filetest" instead?
  my ($readablemask, $writablemask) =
      map { $_ & ($GroupAccessOK ? 007 : 077) } (044, 022);

  my @stat = stat ($Conf{config})
      or die "$me: Could not stat $Conf{config}: $!\n";
  ######## FIXME: make the diagnostic more precise
  die "$me: configuration file $Conf{config} is group/world readable\n"
      if ($stat[2] & $readablemask);
  die "$me: configuration file $Conf{config} is group/world writable\n"
      if ($stat[2] & $writablemask);
}


open CONF,$Conf{config}
    || die "$me: Could not open $Conf{config}: $!\n";
######## FIXME: cannot &log here because LOG isn't opened yet
warn "Reading $Conf{config}" if $Conf{verbose};
while (my $line = <CONF>)
{
  next if ($line =~ /^\s*(?:$|\#)/);
  unless ($line =~ m/^(\S+)\s+(\S.*?)\s*$/)
  {
    die "$me: $Conf{config}:$.: Invalid directive $_";
  }
  ######## TODO: warnings for unsupported directives
  my ($key,$value) = (lc($1), $2);
  $Conf{"$key"} = $value unless defined $Conf{"$key"};
}
close CONF;


# Default parameters and file locations

$Conf{statedir} ||= $Conf{statedir_default};
$Conf{pidfile} ||= "procimap.pid";
$Conf{midfile} ||= "procimap.mid";

$Conf{procmailrc} ||= "procimaprc";
$Conf{wrapper} ||= $Conf{default_wrapper};

# Resolve ~/ to $ENV{HOME}/

$Conf{statedir} =~ s%^~%$ENV{HOME}%;
$Conf{pidfile}  =~ s%^~/%$ENV{HOME}/%;
$Conf{midfile}  =~ s%^~/%$ENV{HOME}/%;
$Conf{procmailrc} =~ s%^~/%$ENV{HOME}/%;
$Conf{wrapper}  =~ s%^~/%$ENV{HOME}/%;
$Conf{logfile}  =~ s%^~/%$ENV{HOME}/% if defined $Conf{logfile};

# procimap.[pm]id: relative paths are relative to $Conf{statedir}
# except explicit ./filename

$Conf{pidfile} =~ s%^([^/,]|\.[^/])%$Conf{statedir}$1%;
$Conf{midfile} =~ s%^([^/.]|\.[^/])%$Conf{statedir}$1%;

$Conf{inbox} ||= "INBOX";

$Conf{delay} ||= 60;
$Conf{maxdelay} ||= 600;

die "$me: No server defined\n" unless $Conf{server};
die "$me: No user name defined\n" unless $Conf{user};
die "$me: No password defined\n" unless $Conf{password};

die "$me: Cannot read $Conf{wrapper}" unless (-r $Conf{wrapper});


# Open the log file

open (LOG, defined $Conf{logfile} ? ">>$Conf{logfile}" : ">&STDERR")
    ######## FIXME: diagnostics are wrong when no logfile is defined
    || die "$me: Could not open $Conf{logfile} for writing: $!\n";
autoflush LOG 1;
&log("startup");

if ($Conf{verbose}) {
  for my $param (qw(config procmailrc server user inbox
		statedir logfile pidfile midfile delay maxdelay
		expunge single-run message wrapper)) {  # password
    my $logval = defined $Conf{"$param"} ? "'$Conf{$param}'" : '(undef)';
    &log("\$Conf{$param} is $logval");
  }
}

unless (defined $Conf{expunge}) {
  &log("expunge preference not explicitly set; defaulting to 0");
  $Conf{expunge} = 0;
}

if ($Conf{expunge} =~ /^(?:no?|off|x|false)$/i) {
  &log("Configuration file 'expunge' directive interpreted as 0 (false)");
  $Conf{expunge} = 0;
} elsif ($Conf{expunge} =~ /^(?:[^01]|[01].)/) {
  &log("Configuration file 'expunge' directive interpreted as " .
       $Conf{expunge} ? "1 (true)" : "0 (false)");
}


# If --message specified, handle and exit

if ($Conf{message}) {
  open (MESSAGE, "<$Conf{message}")
      || die "$me: Could not open $Conf{message}: $!\n";
  my $Message = join ("", <MESSAGE>);
  &log("Read file $Conf{message}, " . length($Message) . " bytes");
  close MESSAGE;

  my ($ResultAction, $NewMessage) = procmail($Message);
  &log("Result: " . (defined $ResultAction ? "'$ResultAction'" : '(undef)'));
  &log("Exiting.") if $Conf{verbose};
  exit 0;
}


# Catch signals

$SIG{TERM} = $SIG{INT} = \&catch_zap;

# See if PID mentioned in PID file (if any) is still around

if (-e $Conf{pidfile}) {
  open  PIDFILE,"$Conf{pidfile}"
      || die "$me: Could not open $Conf{pidfile}: $!\n";
  my $OldPID = <PIDFILE>;
  chomp $OldPID;
  close PIDFILE;
  &log("Read $Conf{pidfile}") if $Conf{verbose};

  my $Group = getpgrp $OldPID;
  if ($Group > 0) {
    &log("Process $OldPID still there -- not starting new instance");
    exit 1;
  }
  &log("Old PID $OldPID gone -- proceeding to start new instance")
      if $Conf{verbose};
}

my $PrevMID = 0;
if (-e $Conf{midfile}) {
  open  MIDFILE,"$Conf{midfile}"
      || die "$me: Could not open $Conf{midfile}: $!\n";
  $PrevMID = <MIDFILE>;
  chomp $PrevMID;
  close MIDFILE;
  &log("Read $Conf{midfile}") if $Conf{verbose};
}
my $LastMID = $PrevMID;
&log("Starting from MID $LastMID") if $Conf{verbose};


# Write new PID file

open (PIDFILE,">$Conf{pidfile}")
    or die "$me: Could not open $Conf{pidfile} for writing: $!\n";
print PIDFILE $$,"\n";
close PIDFILE;
&log("PID $$ written to $Conf{pidfile}") if $Conf{verbose};


#use Mail::IMAPClient 2.0; # Version >= 2.0 required for $@
use Mail::IMAPClient;	   # ... but 2.1.4 has non-numeric version )-:

# Set up connection to IMAP

&log("Connecting to $Conf{server} as $Conf{user} ...") if $Conf{verbose};

my $IMAP = Mail::IMAPClient -> new (Server   => $Conf{server},
                                    User     => $Conf{user},
                                    Password => $Conf{password})
    or die "$me: Connection to $Conf{user}\@$Conf{server} failed: $@\n";
######## BUG: doesn't fail if server doesn't have an address (imap.fastmail.fm)
$IMAP -> select($Conf{inbox})
    or die "$me: Could not select $Conf{inbox}: ", $IMAP->LastError, "\n";
$IMAP->Peek(1);

my %Filtered = (); # Hash of already checked sequence #'s

while (1) {
  ######## TODO: optimize away some of the sorting?
  my @MIDs   = sort numerically $IMAP -> unseen();    # Unread message ID's
  my $MID;
  my $Expunge = 0;			# Whether to do an expunge when done
  foreach $MID (@MIDs) {
    if (!$Filtered{$MID} && $MID > $PrevMID) {
      $Filtered{$MID} = 1;
      $LastMID = $MID;

      # Get message from IMAP and feed to procmail. Retrieve result.

      &log("Retrieving message $MID") if $Conf{verbose};
      my $Message = $IMAP -> message_string($MID);
      &log("Retrieved message $MID, " . length($Message) . " bytes");
      my ($ResultAction, $NewMessage) = procmail($Message);
      if (!defined $ResultAction) {
	$ResultAction = 'keep';
	&log("Undefined result from Procmail -> keep") if $Conf{verbose};
      }
      &log("MID: $MID result: $ResultAction");
      if ($ResultAction =~ /^keep$/ || ! defined $ResultAction) {
	# no action required
	&log("Keeping message $MID") if $Conf{verbose};
      }
      elsif ($ResultAction =~ /^move (.*)/) {
	my $folder = $1;
	&log("Moving message $MID to $folder") if $Conf{verbose};
	# Make copy in new folder; delete original
	######## TODO: maybe add flags and timestamp of original message
        my $AppendStatus = $IMAP->append_string($folder, $NewMessage);
        if ($AppendStatus) {
          $IMAP->set_flag("Seen", $MID);
          $IMAP -> delete_message($MID);
	  $Expunge = 1 if $Conf{expunge};
        } else {
          &log("Error moving message $MID");
        }
      }
      ######## TODO: handle $ResultAction == copy
      ######## TODO: handle $ResultAction == delete
      ######## TODO: warn about unsupported actions

      &cleanupchildren;
    }
  }
  if ($Expunge) {
    $IMAP->expunge();
  }

  exit 0 if $Conf{"single-run"};

  # Sleep and reconnect to server.
  # Use scalable backoff if server is unavailable.

  $IMAP = $IMAP -> disconnect();
  my $connected;
  my $delayTime = $Conf{delay};
  do {
    &log("Sleeping $delayTime seconds ...") if $Conf{verbose};
    sleep $delayTime;
    $delayTime *= 2;
    if ($delayTime > $Conf{maxdelay}) {
      $delayTime = $Conf{maxdelay};
    }
    &log("Attempting to reconnect") if $Conf{verbose};
    $connected = $IMAP -> connect();
  }
  while (!$connected);

  $IMAP -> select($Conf{inbox});
}

sub catch_zap { # Orderly shutdown, remove PID file
  unlink $Conf{pidfile};
  open (MIDFILE,">$Conf{midfile}")
      or die "Could not open $Conf{midfile} for writing: $!\n";
  print MIDFILE $LastMID,"\n";
  close MIDFILE;

  &log("shutdown");

  close LOG;

  exit 0;
}

sub log  { #print to the log file
  my $timestamp = localtime time;
  my $msg = shift;
  print LOG "$timestamp - $msg\n"
}

sub numerically {$a <=> $b;}

sub cleanupchildren {
  1 while (my $kid = waitpid(-1,&WNOHANG) > 0);
}



use Socket;
use IO::Handle;

sub procmail {
  my ($message) = @_;

  unless (socketpair (PROCMAIL, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)) {
    die "$me: socketpair failed: $!";
  }

  PROCMAIL->autoflush(1);
  PARENT->autoflush(1);

  my $pid;
  if ($pid = fork()) {
    close PARENT;
    &log ("Sending message to procmail PID $pid") if $Conf{verbose};
    print PROCMAIL $message;
    shutdown (PROCMAIL, 1);	# Close for writing; signal eof to reader
    my $resultline = <PROCMAIL>;
    my $result;
    if ($resultline =~ /^X-ProcIMAP:\s+(.*)/) {
      $result = $1;
    }
    # else, $resultline was part of message; glue it back while reading rest
    my $message = join ("", $result ? "" : $resultline, <PROCMAIL>);
    close PROCMAIL;
    waitpid($pid, 0);
    ######## FIXME: bail out if procmail died from a signal or returned error
    &log("procmail's exit status: " . ($? >> 8)
	 . " (signal: " . ($? & 127) . ") ($?)") if $Conf{verbose};
    return ($result || undef, $message);
  } else {
    die "$me: cannot fork: $!" unless (defined $pid);
    close PROCMAIL;
    close STDIN;
    close STDOUT;
    close STDERR;
    open (STDIN,  "<&PARENT") || die "Could not dup procmail's STDIN: $!\n";
    open (STDOUT, ">&PARENT") || die "Could not dup procmail's STDOUT: $!\n";
    open (STDERR, ">&LOG")    || die "Could not dup procmail's STDERR: $!\n";

    exec ("procmail", "-m", "PROCIMAPRC=$Conf{procmailrc}", $Conf{"wrapper"})
	|| die "$me: exec failed: $!";

    return undef;
  }
}


=head1 FILES

=over 12

=item F<./procimaprc>

The Procmail recipes in this file are run by default.

=item F<~/.procimap/procimap.conf>

B<procimap>'s settings are retrieved from this file by default.

=item F<~/.procimap/>

The default B<--statedir> directory.

=item F</usr/lib/procimap.rc>

The standard B<--wrapper> file.

=item F<procmail>

The standard F<PATH> environment variable
is used to locate the Procmail binary.

=back


=head1 SEE ALSO

L<procmail(1)>,
L<procmailrc(5)>;
L<Mail::IMAPClient(3p)>

L<http://imapassassin.sourceforge.net/>

L<http://www.procmail.org/>


=head1 BUGS

Requires a configuration file to be present
even when all required parameters are passed in as command-line options.


=head1 LICENSE

The code is partially derived from IMAPassassin
L<http://imapassassin.sourceforge.net/>
which is allegedly GPL (though it's not very explicit).

Therefore, this fork of the code is necessarily
licensed under the GPL as well.

The author of this fork is more than willing to discuss
relicensing under a "new style" BSD license
if that is any help.


=head1 AUTHOR

era eriksson
L<http://www.iki.fi/era/>

=cut
